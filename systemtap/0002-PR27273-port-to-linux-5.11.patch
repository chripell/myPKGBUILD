From 12db52a372f60b87c293c5ff450d95e3b562d1ad Mon Sep 17 00:00:00 2001
From: "Frank Ch. Eigler" <fche@redhat.com>
Date: Thu, 28 Jan 2021 22:12:48 -0500
Subject: [PATCH 2/6] PR27273: port to linux 5.11

Main change is removal/movement of TIF_IA32 in linux commit ff170cd05953
and nearby.  Now using single a central wrapper _stp_is_compat_task() and
_stp_is_compat_task2() functions, instead of sprinkling
test_tsk_thread_flag(...) around the code base.

Also, suppressing CONFIG_DEBUG_INFO_BTF_MODULES generation for stap
modules, for diagnostic noise reduction.
---
 buildrun.cxx                         |  3 ++
 runtime/compatdefs.h                 | 49 +++++++++++++++-------------
 runtime/linux/regs.c                 |  2 +-
 runtime/linux/uprobes2/uprobes_x86.h |  4 +--
 runtime/sym.c                        | 10 +++---
 runtime/syscall.h                    | 14 ++++----
 session.cxx                          |  2 +-
 7 files changed, 45 insertions(+), 39 deletions(-)

diff --git a/buildrun.cxx b/buildrun.cxx
index 9b4066d3a..68a40176a 100644
--- a/buildrun.cxx
+++ b/buildrun.cxx
@@ -116,6 +116,9 @@ make_any_make_cmd(systemtap_session& s, const string& dir, const string& target)
       // PR13847: suppress debuginfo creation by default
       "CONFIG_DEBUG_INFO=",
 
+      // linux 5.11 wants btf but no, baby, no
+      "CONFIG_DEBUG_INFO_BTF_MODULES=",
+      
       // RHBZ1321628: suppress stack validation; expected to be temporary
       "CONFIG_STACK_VALIDATION=",
     };
diff --git a/runtime/compatdefs.h b/runtime/compatdefs.h
index ced68b1c8..0bca4f67d 100644
--- a/runtime/compatdefs.h
+++ b/runtime/compatdefs.h
@@ -10,47 +10,50 @@
 #ifndef _STP_COMPAT_H_ /* -*- linux-c -*- */
 #define _STP_COMPAT_H_
 
-#ifdef CONFIG_COMPAT
-
-/* x86_64 has a different flag name from all other arches and s390... */
+#if defined(CONFIG_COMPAT)
 #include <linux/thread_info.h>
-#if defined (__x86_64__)
-  #define TIF_32BIT TIF_IA32
-#endif
-#if defined(__s390__) || defined(__s390x__)
-  #define TIF_32BIT TIF_31BIT
-#endif
-#if defined (__mips__) && !defined(TIF_32BIT)
-  #ifdef CONFIG_MIPS32_O32
-    #define TIF_32BIT TIF_32BIT_REGS
-  #elif defined(CONFIG_MIPS32_N32)
-    #define TIF_32BIT TIF_32BIT_ADDR
-  #endif
-#endif
 
-#if !defined(TIF_32BIT)
-#error architecture not supported, no TIF_32BIT flag
-#endif
 
 /* _stp_is_compat_task - returns true if this is a 32-on-64 bit user task.
    Note that some kernels/architectures define a function called
    is_compat_task(), but that just tests for being inside a 32bit compat
    syscall. We want to test whether the current task is a 32 bit compat
    task itself.*/
-static inline int _stp_is_compat_task(void)
+static inline int _stp_is_compat_task2(struct task_struct* tsk)
 {
-  return test_thread_flag(TIF_32BIT);
+/* x86_64 has a different flag name from all other arches and s390... */
+#if defined (__x86_64__) && defined(TIF_IA32)
+  return test_tsk_thread_flag(tsk, TIF_IA32);
+#elif defined (__x86_64__) /* post TIF_IA32 */
+  return (tsk->mm && (tsk->mm->context.flags & MM_CONTEXT_UPROBE_IA32));
+#elif defined(__s390__) || defined(__s390x__)
+  return test_tsk_thread_flag(tsk, TIF_31BIT);  
+#elif defined (__mips__) && !defined(TIF_32BIT)
+  #ifdef CONFIG_MIPS32_O32
+  return test_tsk_thread_flag(tsk, TIF_32BIT_REGS);    
+  #elif defined(CONFIG_MIPS32_N32)
+  return test_tsk_thread_flag(tsk, TIF_32BIT_ADDR);      
+  #endif
+#else
+#error architecture not supported, no TIF_32BIT flag?
+#endif
 }
-
 #else
 
-static inline int _stp_is_compat_task(void)
+static inline int _stp_is_compat_task2(struct task_struct* tsk)
 {
   return 0;
 }
 
 #endif /* CONFIG_COMPAT */
 
+static inline int _stp_is_compat_task(void)
+{
+  return _stp_is_compat_task2(current);
+}
+
+
+
 /* task_pt_regs is used in some core tapset functions, so try to make
  * sure something sensible is defined. task_pt_regs is required for
  * the tracehook interface api so is normally defined already.
diff --git a/runtime/linux/regs.c b/runtime/linux/regs.c
index 7d28e68f9..5bcd1031c 100644
--- a/runtime/linux/regs.c
+++ b/runtime/linux/regs.c
@@ -346,7 +346,7 @@ static int _stp_probing_app_with_32bit_regs(struct pt_regs *regs)
 	if (!regs)
 		return 0;
 	return (user_mode(regs) &&
-			test_tsk_thread_flag(current, TIF_32BIT_REGS));
+                _stp_is_compat_task());
 }
 
 void _stp_print_regs(struct pt_regs * regs)
diff --git a/runtime/linux/uprobes2/uprobes_x86.h b/runtime/linux/uprobes2/uprobes_x86.h
index f88a87daa..21ddc25a7 100644
--- a/runtime/linux/uprobes2/uprobes_x86.h
+++ b/runtime/linux/uprobes2/uprobes_x86.h
@@ -38,7 +38,7 @@ typedef u8 uprobe_opcode_t;
 #ifdef CONFIG_X86_32
 #define SLOT_IP(tsk) 12
 #else
-#define SLOT_IP(tsk) (test_tsk_thread_flag(tsk, TIF_IA32) ? 12 : 16)
+#define SLOT_IP(tsk) (_stp_is_compat_task2(tsk) ? 12 : 16)
 #endif
 
 #define BREAKPOINT_SIGNAL SIGTRAP
@@ -111,7 +111,7 @@ static inline unsigned long arch_get_cur_sp(struct pt_regs *regs)
 static inline unsigned long arch_predict_sp_at_ret(struct pt_regs *regs,
 		struct task_struct *tsk)
 {
-	if (test_tsk_thread_flag(tsk, TIF_IA32))
+	if (_stp_is_compat_task2(tsk))
 		return (unsigned long) (regs->sp + 4 + STRUCT_RETURN_SLOP);
 	else
 		return (unsigned long) (regs->sp + 8);
diff --git a/runtime/sym.c b/runtime/sym.c
index a51f08c9e..4b5659577 100644
--- a/runtime/sym.c
+++ b/runtime/sym.c
@@ -142,7 +142,7 @@ static struct _stp_module *_stp_umod_lookup(unsigned long addr,
   void *user = NULL;
 #ifdef CONFIG_COMPAT
         /* Handle 32bit signed values in 64bit longs, chop off top bits. */
-        if (test_tsk_thread_flag(task, TIF_32BIT))
+  if (_stp_is_compat_task2(task))
           addr &= ((compat_ulong_t) ~0);
 #endif
   if (stap_find_vma_map_info(task->group_leader, addr,
@@ -181,8 +181,8 @@ static const char *_stp_kallsyms_lookup(unsigned long addr,
         /* Handle 32bit signed values in 64bit longs, chop off top bits.
            _stp_umod_lookup does the same, but we need it here for the
            binary search on addr below. */
-        if (test_tsk_thread_flag(task, TIF_32BIT))
-          addr &= ((compat_ulong_t) ~0);
+            if (_stp_is_compat_task2(task))
+                    addr &= ((compat_ulong_t) ~0);
 #endif
 	    m = _stp_umod_lookup(addr, task, modname, &vm_start, &vm_end);
 	    if (m)
@@ -376,8 +376,8 @@ unsigned long _stp_linenumber_lookup(unsigned long addr, struct task_struct *tas
 	    unsigned long vm_end = 0;
 #ifdef CONFIG_COMPAT
       /* Handle 32bit signed values in 64bit longs, chop off top bits. */
-      if (test_tsk_thread_flag(task, TIF_32BIT))
-        addr &= ((compat_ulong_t) ~0);
+            if (_stp_is_compat_task2(task))
+                    addr &= ((compat_ulong_t) ~0);
 #endif
 	    m = _stp_umod_lookup(addr, task, &modname, &vm_start, &vm_end);
     }
diff --git a/runtime/syscall.h b/runtime/syscall.h
index 8a1566afe..6b4b3071a 100644
--- a/runtime/syscall.h
+++ b/runtime/syscall.h
@@ -35,19 +35,19 @@
 #define __MUNMAP_SYSCALL_NO_X86_64	11
 #define __MREMAP_SYSCALL_NO_X86_64	25
 # if defined(CONFIG_IA32_EMULATION)
-#define MMAP_SYSCALL_NO(tsk) ((test_tsk_thread_flag((tsk), TIF_IA32))	\
+#define MMAP_SYSCALL_NO(tsk) (_stp_is_compat_task2(tsk) \
 			      ? __MMAP_SYSCALL_NO_IA32			\
 			      : __MMAP_SYSCALL_NO_X86_64)
-#define MMAP2_SYSCALL_NO(tsk) ((test_tsk_thread_flag((tsk), TIF_IA32))	\
+#define MMAP2_SYSCALL_NO(tsk) (_stp_is_compat_task2(tsk) \
 			       ? __MMAP2_SYSCALL_NO_IA32		\
 			       : __MMAP2_SYSCALL_NO_X86_64)
-#define MPROTECT_SYSCALL_NO(tsk) ((test_tsk_thread_flag((tsk), TIF_IA32)) \
+#define MPROTECT_SYSCALL_NO(tsk) (_stp_is_compat_task2(tsk) \
 				  ? __MPROTECT_SYSCALL_NO_IA32		\
 				  : __MPROTECT_SYSCALL_NO_X86_64)
-#define MUNMAP_SYSCALL_NO(tsk) ((test_tsk_thread_flag((tsk), TIF_IA32)) \
+#define MUNMAP_SYSCALL_NO(tsk) (_stp_is_compat_task2(tsk) \
 				  ? __MUNMAP_SYSCALL_NO_IA32		\
 				  : __MUNMAP_SYSCALL_NO_X86_64)
-#define MREMAP_SYSCALL_NO(tsk) ((test_tsk_thread_flag((tsk), TIF_IA32)) \
+#define MREMAP_SYSCALL_NO(tsk) (_stp_is_compat_task2(tsk) \
 				  ? __MREMAP_SYSCALL_NO_IA32		\
 				  : __MREMAP_SYSCALL_NO_X86_64)
 # else
@@ -279,7 +279,7 @@ syscall_get_return_value(struct task_struct *task, struct pt_regs *regs)
 // an argument and then returned won't compare correctly anymore.  So,
 // for now, disable this code.
 # if 0
-	if (test_tsk_thread_flag(task, TIF_IA32))
+	if (_stp_is_compat_task2(task))
 		// Sign-extend the value so (int)-EFOO becomes (long)-EFOO
 		// and will match correctly in comparisons.
 		regs->ax = (long) (int) regs->ax;
@@ -345,7 +345,7 @@ _stp_syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,
 #endif
 #elif defined(__x86_64__)
 #ifdef CONFIG_IA32_EMULATION
-	if (test_tsk_thread_flag(task, TIF_IA32)) {
+	if (_stp_is_compat_task2(task)) {
 		switch (i) {
 #if defined(STAPCONF_X86_UNIREGS)
 		case 0:
diff --git a/session.cxx b/session.cxx
index b5a8044c7..5eba02966 100644
--- a/session.cxx
+++ b/session.cxx
@@ -494,7 +494,7 @@ systemtap_session::version ()
              "Copyright (C) 2005-2020 Red Hat, Inc. and others\n"   // PRERELEASE
              "This is free software; see the source for copying conditions.\n",
              version_string().c_str());
-  cout << _F("tested kernel versions: %s ... %s\n", "2.6.32", "5.10.0-rc");   // PRERELEASE
+  cout << _F("tested kernel versions: %s ... %s\n", "2.6.32", "5.11.0-rc");   // PRERELEASE
   
   cout << _("enabled features:")
 #ifdef HAVE_AVAHI
-- 
2.31.1

